# Sundy
## 虚函数 析构函数 抽象类
### 1. 析构函数和虚析构函数 
    如果基类的析构函数是虚的，那么它的派生类的析构函数都是虚的  
    这将导致：当派生类析构的时候，它的所有的基类的析构函数都将得到调用  
    否则，只调用派生类的析构函数（这可能导致基类的某些对象没有得到释放）     
    所以CObject类的析构函数是虚的，所有由它派生的类析构的时候一级一级的进行，不会造成内存泄漏。
    无论基类的析构函数是否为虚析构函数. 基类的析构函数总是会被自动调用的;但是, 如果用基类指针去操作一个了派生类对象,如果不为虚就不能保证派生类的析构函数被调用。
### 2. 纯虚析构函数
析构函数的纯虚性唯一效果就是保证抽象类的实例化。

《Effective C++》中第14条条款的一部分，既是对虚析构函数的彻底理解，亦是对纯虚析构函数作用的解释。

在某些类里声明纯虚析构函数很方便。纯虚函数将产生抽象类——不能实例化的类（即不能创建此类型的对象）。有些时候，你想使一个类成为抽象类，但刚好又没有任何纯虚函数。怎么办？因为抽象类是准备被用做基类的，基类必须要有一个虚析构函数，纯虚函数会产生抽象类，所以方法很简单：在想要成为抽象类的类里声明一个纯虚析构函数。

	这里是一个例子：
	class awov {
	public:
	  virtual ~awov() = 0;      // 声明一个纯虚析构函数
	};
      这个类有一个纯虚函数，所以它是抽象的，而且它有一个虚析构函数，所以不会产生析构函数问题。但这里还有一件事：必须提供纯虚析构函数的定义：

awov::~awov() {}           // 纯虚析构函数的定义

这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这就是说，即使是抽象类，编译器也要产生对~awov的调用，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来，最后还是得回去把它添上。

### 3. 虚函数  
【1】在基类用virtual声明成员函数为虚函数。这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。

【2】在派生类中重新定义此函数，要求函数名、函数（返回）类型、函数参数个数和类型与基函数的虚函数相同。如果在派生类中没有对基类的虚函数重定义，则派生类简单地继承直接基类的虚函数。

【3】C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数（符合2中定义的函数）都自动成为虚函数。

【4】定义一个指向基类对象的指针变量，并使其指向同一类族中的某个对象。通过该指针变量调用此函数，此时调用的就是指针变量指向的对象的同名函数。

【5】只能用virtual声明类的成员函数，使它成为虚函数，而不能将类外的普通函数声明为虚函数。

【6】一个成员函数被声明为虚函数后，在同一类族中的类就不能再定义一个非virtual的但与该虚函数具有相同参数（个数与类型）和函数返回值类型的同名函数。

【7】静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。

【8】inline函数不能是虚函数，因为inline函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时，仍将其视为非inline的。

【5】使用虚函数，系统要有一定的空间开销。当一个类带有虚函数时，编译器会为该类构造一个虚函数表(virtual function tanle,vtable)，它是一个指针数组，存放每个虚函数的入口地址。

### 4. 纯虚函数

 一个函数声明为纯虚后，纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。

	virtual void show()=0;//纯虚函数

这里将show()声明为纯虚函数(pure virtual function)。纯虚函数是在声明虚函数时被“初始化”为0的虚函数。

声明纯虚函数的一般形式为，virtual 函数类型 函数名(参数列表)=0;
纯虚函数没有函数体；最后的“=0”并不代表函数返回值为0，它只起形式上的作用，告诉编译器“这是纯虚函数”；这个一个声明语句，最后有分号。

声明纯虚函数是告诉编译器，“在这里声明了一个虚函数，留待派生类中定义”。在派生类中对此函数提供了定义后，它才能具备函数的功能，可以被调用。
纯虚函数的作用是在基类中为其派生类保留了一个函数的名字，以便派生类根据需要对它进行定义。

如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该函数在派生类中仍为纯虚函数。

   1．虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类（abstract class），而只含有虚函数的类（class）不能被称为抽象类（abstract class）。
   2． 虚函数可以被直接使用，也可以被子类（sub class）重载以后以多态的形式调用，而纯虚函数必须在子类（sub class）中实现该函数才可以使用，因为纯虚函数在基类（base class）只有声明而没有定义。

   3． 虚函数和纯虚函数都可以在子类（sub class）中被重载，以多态的形式被调用。

   4．虚函数和纯虚函数通常存在于抽象基类（abstract base class -ABC）之中，被继承的子类重载，目的是提供一个统一的接口。

   5．虚函数的定义形式：

		virtual    {method body}
         纯虚函数的定义形式：virtual    { } = 0;
         在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定（run-time bind），而且被两者修饰的函数生命周期（life recycle）也不一样。

6.如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类（ABC）是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。
  
### 5  纯抽象类
   从C++的角度来看，一个抽象类和一个接口之间没有任何区别。有时，我们习惯使用“纯抽象类”这个词来表示某个类仅仅只含有纯虚函数（不包含任何数据成员），它是抽象类的最常见的形式。

   使用纯抽象类有什么好处？最明显的例子就是“多接口、单实现”，这是一种很常见的情况。

   在C++中加入了纯虚函数的概念，一个纯虚函数必须被其派生类重写。借助此概念，你可以在一个C++类中通过将其成员函数声明为纯虚函数的方法表明该类是一个纯接口类。从那以后，我就一直强调在C++中，有一种主要的使用类的方法就是让该类不包含任何状态，而仅仅作为一个接口。

### 6  抽象类

将不用来定义对象而只作为一种基本类型用作继承的类，称为抽象类(abstract class)，由于它常用作基类，通常称为抽象基类。凡是包含纯虚函数的类都是抽象类。

如果在派生类中没有对所有的纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。

可以定义指向抽象类数据的指针变量。当派生类成为具体类后，就可以用这个指针指向派生类对象，然后通过该指针调用虚函数。

带有纯虚函数的类称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。抽象类的主要作用是将有关的组织在一个继承层次结构中，由它来为它们提供一个公共的根，相关的子类是从这个根派生出来的。抽象类刻画了一组子类的操作接口的通用语义，这些语义也传给子类。一般而言，抽象类只描述这组子类共同的操作接口，而完整的实现留给子类。抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类没有重新定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体类了。