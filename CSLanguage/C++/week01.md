#			         C++学习总结week01--OOP
### 涉及内容:

	程序设计简史
	类和对象
	构造函数
	封装和隐藏
	对象的内存结构
一 程序设计简史

- 1 gcc中的汇编器:as
- 2 wps是原金山老总 求伯君 利用汇编语言编写。
- 3 面向机器 面向过程 面向对象 面向组件 面向服务
- 4 C VS C++ (VIP)
- 5 结构体是C和C++之间的桥梁。
- 6 C+OOP+泛型+STL(标准模板库) = C++ 
- 7 #include <iostream.h>  VS #include <iostream>
- 			                using namespace std; //标准命名空间
-  8 cout>>"hello world">>endl; //这里的移位运算符是被重载过的。
-  9 C++中标准的头文件都不用.h,除非自己写的。
-  10 如果不用命名空间,可如下写:
 #include <iostream>   //C++
//using namespace std; //命名空间  可以自己写命名空间

	
		int main(){
			std::cout<<"hello world!"<<endl; //::域运算符，不推荐这样写 cout是一个流对象 <<为流运算符  endl(end line)
			cout<<"please input your name:";
			int age;
			cin>>age;
			cout<<"age">>age>>endl;
			return 0;
		}

二 类和对象

-  0 C  VS C++
-    c语言中数据和对数据的操作是分离的。
-  1 Everyting is object 
-  2 对象:具体的。任何对象都有两样东西:属性 行为，对象是类的实例。
		Time t; //对象为类的变量就是对象

   	类:类是对象的模板。从对象中抽象出类，类是对象的类型。
-  3 封装:对象同时具有属性和行为两项特性。
-  4 注意在C语言中为一个函数传一个结构体参数时，应当传一个结构体指针变量，这样只传了四个字节的内容，方便快捷。
-  如果传一个结构体变量的话，就会增大内存开销。
-  例如:void show(struct Time *p)   VS  void show(struct Time t)
 
-  6  C语言中的struct VS C++中的 struct
	- //C++中的结构体和C语言中的结构体有很大的区别
	- //C++中声明变量时，struct类型修饰符号可以改变
	- //struct在C++的本质就是class! 但是有一点区别,见7,其它的是一摸一样的。

-  7 C++中的类 VS C++中的结构体  （就这么一个区别）
	-   类(class):默认的成员都为私有的
	-   结构体(struct)：默认的成员都为公有的
	-   类 对象(Time是t的类型,t就是Time类型的一个变量)
	

	8 类中包含两种成员
	-   a 成员变量(属性):数据成员
	-   b 成员函数(行为):构造函数，析构函数(不能重载)，普通成员函数

-  9 析构函数:~Time(){};
	-   a 析构函数在默认的构造函数前面加一个~符号
	-   b 析构函数不能重载，也没有参数。
	-   c 析构函数用于销毁对象的成员。

-  10 this指针，指向当前类的对象。见专题1-2

-  11 任何变量都有地址，同理，对象也有地址 &对象名 即为对象的地址。
 
**四 构造函数(是创建对象的必经之路)**

1. 1 创建一个对象，一定要调用一个构造函数
	构造函数；没有显示定义时,系统会自动给我们一个默认无参的构造函数。
-  构造函数的特点：
	-     a 名字和类名相同
	-     b 没有任何返回类型
	-     c 构造函数可以私有

			class A{
				int n;
				const int t; //常量的初始化,只能用初始化列表
			private:
				A():t(0){};  //构造函数可以私有，但是不能调用它来创建对象。
			}

3-  没有返回值  VS  没有返回类型

		void show(); VS  show();


4 构造函数的作用:初始化成员变量

			-   Time(int h, int m, int s) {
			- 		printf("three param constructor!\n");
			- 		this->h = h; //解决命令冲突
			- 		this->m = m;
			- 		this->s = s;
			- 	}

 5 函数的重载(overload):

1. 参数名相同
1. 参数列表不同(参数个数，参数类型，参数顺序)。  

 6 访问修饰符 private protected public

 7 输出流都有缓存，输出时必须刷新 ()

		void show() {
			//printf("%02d:%02d:%02d\r", this->h, this->m, this->s);
			cout<<h<<":"<<m<<":"<<s<<"\r";
			fflush(stdout); //刷新缓冲区
			}

 8 分离的思想：

-   a 所有的类型定义都放到头文件中去
-   b 函数的声明和函数的实现分开

 9 类型域作用符(::):（ “::”要紧跟在成员函数前面）

 例如：Time::Time(){};

	 void Book::detail(){  //Book::要紧跟在成员函数前面
		cout<<"name = "<<name<<",pageNum = "<<pageNum<<",type="<<type<<endl;
	}

 10 形参默认值:

	void order(char *name,int n=1){  //形参默认值
		cout<<"点了"<<n<<"份"<<name<<endl;
	 }  //如果在调用此函数时，没有给第二个参数赋值，则默认的为1
	      如果给第二个参数赋了值，则覆盖默认值。

 11 C++中在类中不能直接给成员变量赋值。

	  class A{
		int n = 100; //error
	  }；
    
 12 对于成员常量只能用初始化列表赋值

		class A{
			int n;
			const int t; //常量的初始化,只能用初始化列表
		public:
			A(int n,int t):t(t){
				cout<<"A("<<n<<")"<<endl;
				this->n = n;
			}
		
			void show(){
				cout<<"n="<<n<<",t="<<t<<endl;
			}
		};

 13 C++中的非构造函数必须写明返回类型，否则错误。

 14 析构的顺序和构造的顺序相反。
 
	全局对象和栈对象 都会由系统自动析构，而堆对象需要手动析构delete 堆对象指针。

 15 注意:当需要创建一个对象时，一定会调用构造函数。
         当一个对象的生命周期到了之后，一定会调用析构函数。

五 封装和隐藏

1. 封装:对象同时具有属性和行为两项特性。
1. 函数的重载:函数的重载(overload):

	    a 参数名相同
	    b 参数列表不同(参数个数，参数类型，参数顺序)。
	    c 与返回值无关

六 对象的内存结构(见专题1-3)

	1 栈对象
	2 堆对象
	3.全局对象
	4 局部静态对象
	5 无名对象：没有名字，一次性析构的对象。
	6.常量对象：只能调用常函数

对象引用：

对象指针：A *a = new A(); //a就为对象指针


七 引用(取别名，如同硬链接)
&符号的多用

	     1. &i取地址 
	     2. 3&4 按位与 
	     3. a>0 && b<0 逻辑与 
	     4.  int &i = j; 定义一个引用类型



**作业:**

- 1 C语言能否做面向对象的设计。（可以）见专题1.1
  
- 2 有哪一些成员必须用初始化列表初始化，有哪一些成员必须用构造函数进行初始化。
哪些成员既可以用初始化列表又可以用构造函数初始化？
以下三种情况必须使用初始化成员列表进行初始化:

	 (1)需要初始化的成员是对象的情况
	 (2)需要初始化const修饰的类成员 
	 (3)需要初始化引用成员数据 
	 (4)需要初始化父类成员
以下两种情况必须使用构造函数进行初始化
   (1) 数组
   (2) 结构体
其它的成员既能在构造函数中初始化，也能用初始化成员列表进行初始化。

- 3 一个空类到底有什么？一个空类的大小？
	有默认的构造函数，拷贝默认构造函数，默认拷贝赋值操作符，默认析构函数。
	一个空类的sizeof(A)大小为:1

- 4  一个空类的sizeof(A)大小为:1 为什么？
原因:那是被编译器插进去的一个char,使得这个class的实体在内存中配置独一无二的地址。   
