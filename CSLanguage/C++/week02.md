# Sundy
## C++学习总结week02
### 一.复习上节课
1 对象（抽象成）->类，对象是具体的，单个的一个实体

- 类是抽象的，是一个模板。
	- 例如:类（学校)，对象（经济学院）

2 使用对象的流程:

- 定义（创建类）类  class A{};
- 创建对象(定义变量)

		A a;  （自定义的类型优先级最高）
		A  a;
		int i;
		a = i; //ok  (类A拥有一个带int型参数的构造函数)

- 3.使用对象     a.fun();//OO     show(a) //OP

3.面向过程 VS 面向对象

1. 软件复用(软件重用，层次)：c语言重用函数，C++类(若干的数据和操作)
2. 设计和使用角度:(例如设计一个屏幕移动)
 
		C：  struct Screen{数据};  move(Screen *p)
		C++: class Screen{数据和操作}; Screen s; s.move();
3. 源于生活:考虑问题的方式方法决定了我们的编码。
 
		例如:开车去汉口
			步骤:面向过程:按照步骤一步一步的做事。
			     面向对象:车.go();
4. 可扩展性，通用性:(例如下围棋中的悔棋)
 
	面向过程:牵一发动全身(面向过程的可扩展行和可维护性不高)：下棋人，棋盘，棋子，下棋规则。从而设计各自的方法。（宏观OO，微观OP）
	
	面向对象:不考虑具体怎么做

4 构造函数(构造器)

- 特点:名字与类名相同，无参无返回值。
- 功能:构造函数是创建对象的标志。
- 对象的生命周期开始的时候 自动 调用。

5 函数重载(overload)：函数名相同，参数列表不同，与返回值无关。

6 析构函数:功能和构造函数相反。当对象的生命周期结束时 自动 调用

7 初始化列表:A(int i):成员(形参){this->i = i;}; (VIP)

	以下三种情况必须使用初始化成员列表进行初始化:
		(1)需要初始化的成员是对象的情况
			class B{B(int i){}};
			class A{int i;int &j;B b};
		(2)需要初始化const修饰的类成员 
   		(3)需要初始化引用成员数据 
   		(4)需要初始化父类成员

以下两种情况必须使用构造函数进行初始化
	(1) 数组
	(2) 结构体

其它的成员既能在构造函数中初始化，也能用初始化成员列表进行初始化。

8 this指针：指向当前对象。一个对象对应一个this

	class C{
		int m;
	public:
		C(){cout<<this<<endl;};
	}
	int main()
	{
		C c,c2;
		cout<<&c<<&c2<<endl;
	}

分析:共打印三条语句

9 形参默认值 

10 各种对象

-   (1) 栈对象
-   (2) 堆对象
-   (3) 全局对象
-   (4) 静态全局对象
-   (5) 无名对象
-   (6) 引用对象
-   (7) 常量对象
-   (8) 对象指针

		class A{
		   int i;
		public:
		   A(int i=3){}
		   void show(){}
		   vois show() const{}   //常函数:在函数中不能修改变量的值
		}；
		
		A a2(){
			return A();
		}

		void stackObject(){
		  A a;          //栈对象
		  A a2();	//函数的声明(function declare)，不能创建对象。
		  A a3(3);	//栈对象
		  A a4 = 4;	//栈对象 等价于 A a4(4);
		  A();		//无名对象
		  A(6)		//无名对象
		  A a5 = A(5);	//OK A(5)创建一个无名对象然后拷贝一份给a5,然后自己立即销毁
		}
		
		void heapObject(){
		  A *p = new A(); //堆对象  A *p = new A(20)
		  delete p;
		  
		  p = new A[2];   //在堆中创建2个连续分配的类数组,p指向数组首地址，p本身在栈中。
		                  //2个堆对象分别为p[0],p[1]
		  delete p ;      //只能删除第一个。
		  delete[] p;     //删除p[0],p[1]
		}
		
		int i;
		A  a  ;           //全局对象(类比全局变量)，在main函数前创建。
		
		void staticObject(){
		  static A a;     //第一次执行这行代码时创建对象(创建初始化一次)，程序结束时销毁
		}
		
		void  fn4(){
		   A a,a2;          //引用终生制，不能再是别个对象的引用
		   A &b = a; //OK     alias引用对象必须初始化,从此b只能是a的引用(别名)。
		// b = a2;   //	ERROR 赋值(asigment)
		   A &c = b; //OK     a,b,c是同一个对象	
		}
		
		
		void constObject(){
		   const A a;  //常对象只能访问常函数
		   a.show();   //调用的是常函数
		   A a2;     
		   a2.show();  //普通对象优先调用普通函数(普通函数优先级高于常量函数)，如果没有普通函数则调用常函数。
		}
		
		常函数 VS 返回值为常量的函数
		 void show() const{}   VS  const void show(){}

**二  OOP进阶**

1 注意只有一个参数且有默认值的函数   VS  无参函数

	A():data(0){
		cout<<"A()"<<endl;
	};
	A(int i =0):data(i){
		cout<<"A("<<data<<")"<<endl;
	}

他们不是函数的重载，重复了。

2 类型转换有两种方法:

	(1) (类型) 变量  
	(2)  类型  (变量)
3 自定义的类型 优先级高于 固有的类型

	A a5 = A(5);   或者 A a5 = (A)5  
	分析:尽管5是int型变量，但是类A的优先级高于int，所以优先转化为A
 4 引用(&)  VS 指针(*)

	引用:仅仅是给变量取别名，是同一段内存的多个映射。因此引用本身不占内存。 
	int &j = i;   //引用是终身制
	指针:本身栈相对应的内存空间。

5 函数返回引用

	int& fn(){
		int n =5;
		int &n2 =n;
		return n2;  //不能返回局部变量的引用 error
		//return n; //不能返回局部变量的引用 error
	}

	int& fn2(){
		static int n = 5
		int &n2 = n;
		return n2;
		//return n;  //ok
	}

6 static的用法（既可以修饰成员数据，也可以修饰成员函数）

- 对象拥有独立的数据，如果想要该类的所有的对象都共享同一份数据，要用static修饰
- 先有类，再有对象
- static修饰的成员属于类(所有对象共享)，普通成员是属于对象(每个对象独有)
所以静态成员不能访问非静态成员，但是非静态成员可以访问静态成员。


- 静态成员必须在类外部进行初始化:

		string Student::teacher = "郭老师";
		string Student::classroom = "计科(1)班";

7 拷贝构造函数

-     拷贝构造函数的经典写法:
     
		B(const B& b){
		cout<<"B(copy)"<<endl;
		};
		不能写成:B(B b){};  //会产生死循环，所以应该用引用解决.B(B &b){};
		为了保护引用，所以加const修饰。


- 调用拷贝构造函数时，只是将实参的值赋给形参，不会给成员赋值，所以需要我们手动赋值。		
 
		C(C &c):i(c.i){cout<<"C(copy)"<<endl;}

- 深拷贝 VS 浅拷贝
 
	默认的拷贝构造函数会逐字节地拷贝旧对象的成员到新对象的成员。会造成成员中有的指针指向的数据无法拷贝。详细见专题2-2

- string类型
 
	string类型是一个C++中一个新的数据类型。
	支持:string s1,s2; s1 = s2;


**作业:**

1 利用static设计一个单子模式（单例模式），即设计一个类，该类只能创建一个对象。

   详细见专题2-3