# Sundy
## C++学习总结week04
涉及内容:

	友员函数和友员类
	运算符重载
	三原则
	多重继承和虚继承
	异常和内部类

### 一.复习上节课
1  指针和引用的5大不同点？

	(1) 引用不能修改，指针可以
	(2)	引用必须被初始化，指针不需要  A *p;//ok   A &p; //eror
	(3) 引用不能为NULL,指针可以
	(4) 引用只是别名，不是拷贝，又不是地址。而指针代表的就是变量的地址。
	(5) 应用名本身没有地址，而指针变量名有地址。
	 
2 在C++头文件中，声明static函数(不是成员函数)的作用？

    (1) 缩小了作用域，该函数只能在包含该头文件的源文件中实现并使用，脱离本源文件文件之后无法使用。

	例如:    a.h                       a.cc
	        static void fn()；	   #include　"a.h"
	static void fn(){cout<<"static"}//此时，fn()只能在a.h中使用要想被其他的文件调用，需要在a.cc中写一个非 static函数，如void fn2(){fn();} ,然后其他文件可以通过调用fn2()函数，从而间接的调用fn();

3 虚函数（构造函数不能为虚函数，析构函数可以为虚函数）

	class A{
	public:
		virtual A(){}       //error 为什么构造函数不能为虚？
		virtual ~A(){}      //尽量将析构函数声明为虚函数。存在多态时父类的析构函数必须为虚析构函数。
		virtual	void fn(){} //ok 虚函数的地址存放在虚函数表中(V TABLE),虚函数表指针指向此虚函数表。
		virtual	void fn2(){} //ok 
		void fn3()      //普通函数，函数名就是地址，调用的时候就会找到。
	}
	虚函数在C++中是为实现多态而存在。
	实现多态是有代价的。


-   (1) 虚函数表指针 指向 虚函数表(V TABLE:存放虚函数的地址)：虚函数表指针也是类的一个成员。(隐式存在)
-   (2)创建对象的过程:
	-   (1) 先分配内存空间。
	-   (2) 再调用构造函数(初始化为成员分配的空间)
	
  (3)！！！为什么构造函数不能为虚？

	如果构造函数为虚函数的话,当创建对象的时候，调用此虚构造函数进行初始化操作，
	构造函数的地址都找不到，何以找到虚函数表指针，何以进行初始化？那么对象的内存空间不就是乱七八糟的吗？  综上，构造函数不能是虚函数。
  (4) ！！！为什么存在多态时父类的析构函数必须为虚析构函数？

	  详细分析见 专题4-1

4 抽象类:

只要一个类中有一个纯虚函数，则该类就是抽象类，该类只能做父类，不能进行实例化。

	(1)析构函数能否为纯虚析构函数？virtual ~A()= 0  //??????
    	详见专题4-1

 5 性质

	继承特性 private protected private
	继承方式 private protected private
	类内部 子类中 外部。
 
 6 多态的概念:对一个动作执行多种状态。

  （1） 生活中的多态

		车辆
		机动车 人力车 畜力车
		停
		踩刹车  捏刹车 拉缰绳
		cut
		演员    理发师  医生

  （2）多态的实现条件

      继承
      虚函数
      覆盖
      父类的指针或引用访问子类的实例。
以下哪些情况可以实现多态？  见专题3-2	

        A a;
	B b;
	A* p = &a;      //NO 无多态
	A* p =&b;       //YES 父类指针访问子类对象
	A& p = a;       //NO 无多态 普通的引用
	A& p = b;       //YES 父类引用访问子类对象
	A* p = new B;   //YES 父类指针访问子类对象
	A& p  =new B;   //NO 无多态 类型不匹配
	A& p  =*(new B); //NO 无多态  C++不允许此语法
	A p = b;         //NO 无多态 copy construct  A p(b); 子类的对象永远可以当成父类对象使用。
  
   
### 二 友员函数和友员类
  1 友元是内部授权的，它不是成员，友元声明不受访问修饰符的影响，里面没有this，友元函数的声明和定义可以不分开。
    友元关系不能反转，不能传递，也不能继承。

	#include <iostream>
	using namespace std;
	//友员不受修饰符的限制
	class C{
	private:
		int i;
		//编译器 后门授权
		friend void access(const C& c); //友员函数
		friend class D; //友员类
	public:
		//friend void access(const C& c); //友员函数
		C(int i = 10):i(i){}
	};
	
	void access(const C& c){
		cout<<c.i<<endl;
	}
	
	class D{
	public:
		void twice(C&c){
			c.i *= 2;
		}
	};
	
	int main(){
		C c;
		access(c);
		D d;
		d.twice(c);
		access(c);
		return 0;
	}


### 三 运算符的重载
 1.实现运算符重载,就是编写相应的运算符函数。

	   函数必须以operator开头
	   实现方式: 1. 友员方式  2.成员方式
	详细见专题 4-3
	  注意friend Complex operator++(Complex& c,int);	//后自增 int的作用只是为了区分前增，别无它用。系统默认给他赋0值
 
 2 注意:C++中很多运算符都被语言本身重载，如果语言已经重载，我们不能再写和语言重载一样的函数。

	 例如:string operator=(Complex&c1,Complex&c1);  //语言本身已经重载，我们不能再写

 3 错误：‘Complex operator=(Complex&, Complex&)’ 必须是一个非静态的成员函数????
分析:

 4 运算符= [] 这两个运算符必须以成员函数的形式进行重载。

### **作业:**

 1 写一个复数类(实部，虚部 + - * / (前)++ (前)-- 后++(int) 后-- << >>)

 2 写一个String类(包含String里面的所有)(+,+=(相当于c语言中的strcat),=(strcpy),[])
 
